<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>WebDriver</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>WebDriver</h1>
<p><A href="https://www.selenium.dev/zh-cn/documentation/webdriver/" target=_blank >WebDriver </A>以本地化方式驱动浏览器，就像用户在本地或使用 Selenium 服务器的远程机器上所做的那样，这标志着浏览器自动化的飞跃。</p>
<h2>安装命令</h2>
<pre><code>pip install selenium
</code></pre>

<h2>使用案例</h2>
<pre><code>from selenium import webdriver
from selenium.webdriver.chrome.service import Service

service = Service(executable_path="/path/to/chromedriver")
driver = webdriver.Chrome(service=service)
</code></pre>

<h2>浏览器使用</h2>
<table>
<thead>
<tr>
	<th align="left">浏览器</th>
	<th align="left">支持操作系统</th>
	<th align="left">维护者</th>
	<th align="left">下载</th>
	<th align="left">问题追溯</th>
</tr>
</thead>
<tbody>
<tr>
	<td align="left">Chromium/Chrome</td>
	<td align="left">Windows/macOS/Linux</td>
	<td align="left">Google</td>
	<td align="left"><A href="https://chromedriver.chromium.org/downloads">下载</A></td>
	<td align="left"><A href="https://bugs.chromium.org/p/chromedriver/issues/list">Issues</A></td>
</tr>
<tr>
	<td align="left">Firefox</td>
	<td align="left">Windows/macOS/Linux</td>
	<td align="left">Mozilla</td>
	<td align="left"><A href="https://github.com/mozilla/geckodriver/releases">下载</A></td>
	<td align="left"><A href="https://github.com/mozilla/geckodriver/issues">Issues</A></td>
</tr>
<tr>
	<td align="left">Edge</td>
	<td align="left">Windows/macOS/Linux</td>
	<td align="left">Microsoft</td>
	<td align="left"><A href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">下载</A></td>
	<td align="left"><A href="https://github.com/MicrosoftDocs/edge-developer/issues">Issues</A></td>
</tr>
<tr>
	<td align="left">Internet Explorer</td>
	<td align="left">Windows</td>
	<td align="left">Selenium Project</td>
	<td align="left"><A href="https://www.selenium.dev/downloads/">下载</A></td>
	<td align="left"><A href="https://github.com/SeleniumHQ/selenium/labels/D-IE">Issues</A></td>
</tr>
<tr>
	<td align="left">Safari</td>
	<td align="left">macOS High Sierra and newer</td>
	<td align="left">Apple</td>
	<td align="left">内置</td>
	<td align="left"><A href="https://feedbackassistant.apple.com/">Issues</A></td>
</tr>
</tbody>
</table>
<h2>浏览器使用案例</h2>
<h2>Chrome</h2>
<pre><code>from selenium import webdriver
from selenium.webdriver import ChromeOptions

#设置操作的网站
web_url = "https://bbs.csdn.net"
browser = webdriver.Chrome(executable_path=r"D:\chromedriver_win32\chromedriver\chromedriver.exe")
#打开网页
browser.get(web_url)
</code></pre>

<h3>Options</h3>
<pre><code>options = ChromeOptions()
driver = webdriver.Chrome(options=options)
</code></pre>

<h3>args 参数是启动浏览器时输入的浏览器命令行参数.</h3>
<pre><code>chrome_options = ChromeOptions()
chrome_options.add_argument("--headless=new")
</code></pre>

<h3>将 detach 参数设置为true将在驱动过程结束后保持浏览器的打开状态.</h3>
<pre><code>chrome_options = ChromeOptions()
chrome_options.add_experimental_option("detach", True)
</code></pre>

<h2>Firefox</h2>
<pre><code>from selenium import webdriver

# 创建浏览器对象
driver = webdriver.Firefox()

# 访问网页
driver.get("https://www.example.com")
</code></pre>

<h3>Options</h3>
<pre><code>options = FirefoxOptions()
driver = webdriver.Firefox(options=options)
</code></pre>

<h3>Arguments</h3>
<p>args参数用于启动浏览器时使用的命令行开关列表。</p>
<p>常用的参数包括-headless和“-profile”、“/path/to/profile”</p>
<pre><code>options=Options()
options.add_argument("-profile")
options.add_argument("/path/to/profile")
</code></pre>

<h3>Profiles</h3>
<p>有几种方法可以使用Firefox配置文件</p>
<pre><code>from selenium.webdriver.firefox.options import Options
from selenium.webdriver.firefox.firefox_profile import FirefoxProfile
options=Options()
firefox_profile = FirefoxProfile()
firefox_profile.set_preference("javascript.enabled", False)
options.profile = firefox_profile
</code></pre>

<h3>设置</h3>
<pre><code>path = os.path.abspath("tests/extensions/webextensions-selenium-example.xpi")
driver.install_addon(path)
</code></pre>

<h3>卸载</h3>
<pre><code>path = os.path.abspath("tests/extensions/webextensions-selenium-example.xpi")
id = driver.install_addon(path)
driver.uninstall_addon(id)
</code></pre>

<h3>未签名的安装</h3>
<pre><code>path = os.path.abspath("tests/extensions/webextensions-selenium-example/")
driver.install_addon(path, temporary=True)
</code></pre>

<h2>EDGE</h2>
<h3>选项</h3>
<pre><code>options = EdgeOptions()
driver = webdriver.Edge(options=options)
</code></pre>

<h3>Arguments</h3>
<pre><code>options = EdgeOptions()
options.add_argument("--headless=new")
</code></pre>

<h2>IE</h2>
<h3>Options</h3>
<pre><code>options = InternetExplorerOptions()
driver = webdriver.Ie(options=options)
</code></pre>

<h3>fileUploadDialogTimeout</h3>
<p>在某些环境中, 当打开文件上传对话框时, Internet Explorer可能会超时. IEDriver的默认超时为1000毫秒, 但您可以使用fileUploadDialogTimeout功能来增加超时时间.
	from selenium import webdriver</p>
<pre><code>options = webdriver.IeOptions()
options.file_upload_dialog_timeout = 2000
driver = webdriver.Ie(options=options)

driver.get("http://www.google.com")

driver.quit()
</code></pre>

<h3>ensureCleanSession</h3>
<p>设置为 true时, 此功能将清除InternetExplorer所有正在运行实例的 缓存, 浏览器历史记录和Cookies (包括手动启动或由驱动程序启动的实例) . 默认情况下，此设置为 false.</p>
<p>使用此功能将导致启动浏览器时性能下降, 因为驱动程序将等待直到缓存清除后再启动IE浏览器.</p>
<p>此功能接受一个布尔值作为参数.</p>
<pre><code>from selenium import webdriver

options = webdriver.IeOptions()
options.ensure_clean_session = True
driver = webdriver.Ie(options=options)

driver.get("http://www.google.com")

driver.quit()
</code></pre>

<h3>ignoreZoomSetting</h3>
<p>InternetExplorer驱动程序期望浏览器的缩放级别为100%, 否则驱动程序将可能抛出异常. 通过将 ignoreZoomSetting 设置为 true, 可以禁用此默认行为.</p>
<p>此功能接受一个布尔值作为参数.</p>
<pre><code>from selenium import webdriver

options = webdriver.IeOptions()
options.ignore_zoom_level = True
driver = webdriver.Ie(options=options)

driver.get("http://www.google.com")

driver.quit()
</code></pre>

<h3>ignoreProtectedModeSettings</h3>
<p>启动新的IE会话时是否跳过 保护模式 检查.</p>
<p>如果未设置, 并且所有区域的 保护模式 设置都不同, 则驱动程序将可能引发异常.</p>
<p>如果将功能设置为 true, 则测试可能会变得不稳定, 无响应, 或者浏览器可能会挂起. 但是, 到目前为止, 这仍然是第二好的选择, 并且第一选择应该 始终 是手动实际设置每个区域的保护模式设置. 如果用户正在使用此属性， 则只会给予 “尽力而为” 的支持.</p>
<p>此功能接受一个布尔值作为参数.
	from selenium import webdriver</p>
<pre><code>options = webdriver.IeOptions()
options.ignore_protected_mode_settings = True
driver = webdriver.Ie(options=options)

driver.get("http://www.google.com")

driver.quit()
</code></pre>

<h3>silent</h3>
<p>设置为 true时, 此功能将禁止IEDriverServer的诊断输出.</p>
<p>此功能接受一个布尔值作为参数.<br >
	from selenium import webdriver</p>
<pre><code>options = webdriver.IeOptions()
options.set_capability("silent", True)
driver = webdriver.Ie(options=options)

driver.get("http://www.google.com")

driver.quit()
</code></pre>

<h3>IE 命令行选项</h3>
<p>Internet Explorer包含几个命令行选项, 使您可以进行故障排除和配置浏览器.</p>
<p>下面介绍了一些受支持的命令行选项</p>
<p>-private : 用于在私有浏览模式下启动IE. 这适用于IE 8和更高版本.</p>
<p>-k : 在kiosk模式下启动Internet Explorer. 浏览器在一个最大化的窗口中打开, 该窗口不显示地址栏, 导航按钮或状态栏.</p>
<p>-extoff : 在无附加模式下启动IE. 此选项专门用于解决浏览器加载项问题. 在IE 7和更高版本中均可使用.</p>
<p>注意: forceCreateProcessApi 应该启用命令行参数才能正常工作.<br >
	from selenium import webdriver</p>
<pre><code>options = webdriver.IeOptions()
options.add_argument('-private')
options.force_create_process_api = True
driver = webdriver.Ie(options=options)

driver.get("http://www.google.com")

driver.quit()
</code></pre>

<h3>forceCreateProcessApi</h3>
<p>强制使用CreateProcess API启动Internet Explorer. 默认值为false.</p>
<p>对于IE 8及更高版本, 此选项要求将 “TabProcGrowth” 注册表值设置为0.<br >
	from selenium import webdriver</p>
<pre><code>options = webdriver.IeOptions()
options.force_create_process_api = True
driver = webdriver.Ie(options=options)

driver.get("http://www.google.com")

driver.quit()
</code></pre>

<h2>简单案例：</h2>
<pre><code># 驱动会话
driver = webdriver.Chrome()
# 导航 到一个网页.
driver.get("https://www.selenium.dev/selenium/web/web-form.html")
# 浏览器的信息 , 包括窗口句柄、浏览器尺寸/位置、cookie、警报等.
title = driver.title
# 建立等待策略
driver.implicitly_wait(0.5)
# 查找元素 
text_box = driver.find_element(by=By.NAME, value="my-text")
submit_button = driver.find_element(by=By.CSS_SELECTOR, value="button")
#  操作元素
text_box.send_keys("Selenium")
submit_button.click()
#  获取元素信息
value = message.text
#  结束会话
driver.quit()
</code></pre>

<h2>使用 findElement* 查找单个元素</h2>
<h2>Before</h2>
<pre><code>driver.findElementByClassName("className");
driver.findElementByCssSelector(".className");
driver.findElementById("elementId");
driver.findElementByLinkText("linkText");
driver.findElementByName("elementName");
driver.findElementByPartialLinkText("partialText");
driver.findElementByTagName("elementTagName");
driver.findElementByXPath("xPath");
</code></pre>

<h2>After</h2>
<pre><code>driver.findElement(By.className("className"));
driver.findElement(By.cssSelector(".className"));
driver.findElement(By.id("elementId"));
driver.findElement(By.linkText("linkText"));
driver.findElement(By.name("elementName"));
driver.findElement(By.partialLinkText("partialText"));
driver.findElement(By.tagName("elementTagName"));
driver.findElement(By.xpath("xPath"));
</code></pre>

<h2>使用 findElements* 查找多个元素</h2>
<h2>Before</h2>
<pre><code>driver.findElementsByClassName("className");
driver.findElementsByCssSelector(".className");
driver.findElementsById("elementId");
driver.findElementsByLinkText("linkText");
driver.findElementsByName("elementName");
driver.findElementsByPartialLinkText("partialText");
driver.findElementsByTagName("elementTagName");
driver.findElementsByXPath("xPath");
</code></pre>

<h2>After</h2>
<pre><code>driver.findElements(By.className("className"));
driver.findElements(By.cssSelector(".className"));
driver.findElements(By.id("elementId"));
driver.findElements(By.linkText("linkText"));
driver.findElements(By.name("elementName"));
driver.findElements(By.partialLinkText("partialText"));
driver.findElements(By.tagName("elementTagName"));
driver.findElements(By.xpath("xPath"));
</code></pre>

<h2>查询网络元素</h2>
<p>根据提供的定位值定位元素.
使用Selenium最基本的一个方面是获得要使用的元素引用。Selenium提供了许多内置的定位器策略来唯一地识别元素。有很多方法可以在非常高级的场景中使用定位器。出于本文档的目的，让我们考虑以下HTML片段：</p>
<pre><code>&lt;ol id="vegetables"&gt;
 &lt;li class="potatoes"&gt;
 &lt;li class="onions"&gt;
 &lt;li class="tomatoes"&gt;&lt;span&gt;Tomato is a Vegetable&lt;/span&gt;
&lt;/ol&gt;
&lt;ul id="fruits"&gt;
  &lt;li class="bananas"&gt;
  &lt;li class="apples"&gt;
  &lt;li class="tomatoes"&gt;&lt;span&gt;Tomato is a Fruit&lt;/span&gt;
&lt;/ul&gt;
</code></pre>

<h3>第一个匹配元素</h3>
<p>许多定位器将与页面上的多个元素相匹配。单数find元素方法将返回对给定上下文中找到的第一个元素的引用</p>
<h4>查找整个DOM</h4>
<p>当在驱动程序实例上调用find元素方法时，它会返回对DOM中与所提供的定位器匹配的第一个元素的引用。此值可以存储并用于将来的元素操作。在我们上面的示例HTML中，有两个元素的类名为“番茄”，因此此方法将返回“蔬菜”列表中的元素。</p>
<pre><code>vegetable = driver.find_element(By.CLASS_NAME, "tomatoes")
</code></pre>

<h4>查找DOM的子集</h4>
<p>
与其在整个DOM中找到唯一的定位器，不如将搜索范围缩小到另一个已定位元素的范围。在上面的例子中，有两个元素的类名为“tomatos”，而要获得第二个元素的引用则有点困难。一种解决方案是定位具有唯一属性的元素，该元素是所需元素的祖先，而不是不需要的元素的祖先。然后在该对象上调用find元素：</p>
<pre><code>fruits = driver.find_element(By.ID, "fruits")
fruit = fruits.find_element(By.CLASS_NAME,"tomatoes")
</code></pre>

<h4>优化定位器</h4>
<p>嵌套查找可能不是最有效的定位策略，因为它需要向浏览器发出两个单独的命令。</p>
<p>为了稍微提高性能，我们可以使用CSS或XPath在一个命令中找到这个元素。请参阅我们鼓励的测试实践部分中的定位器策略建议。</p>
<p>对于本例，我们将使用CSS选择器：</p>
<pre><code>fruit = driver.find_element(By.CSS_SELECTOR,"#fruits .tomatoes")
</code></pre>

<h4>所有匹配元素</h4>
<p>有几个用例需要获取对匹配定位器的所有元素的引用，而不仅仅是第一个。复数find元素方法返回元素引用的集合。如果没有匹配项，则返回一个空列表。在这种情况下，对所有水果和蔬菜列表项的引用将在集合中返回。</p>
<pre><code>plants = driver.find_elements(By.TAG_NAME, "li")
</code></pre>

<h4>获取元素</h4>
<p>通常，您得到一个元素集合，但想要使用特定的元素，这意味着您需要迭代该集合并确定您想要的元素。<br >
	from selenium import webdriver
	from selenium.webdriver.common.by import By</p>
<pre><code>driver = webdriver.Firefox()

    # Navigate to Url
driver.get("https://www.example.com")

    # Get all the elements available with tag name 'p'
elements = driver.find_elements(By.TAG_NAME, 'p')

for e in elements:
    print(e.text)
</code></pre>

<h4>从元素中查找元素</h4>
<p>它用于在父元素的上下文中查找匹配的子WebElement的列表。为了实现这一点，父WebElement与“findElements”链接以访问子元素
	from selenium import webdriver
	from selenium.webdriver.common.by import By</p>
<pre><code>driver = webdriver.Chrome()
driver.get("https://www.example.com")

    # Get element with tag name 'div'
element = driver.find_element(By.TAG_NAME, 'div')

    # Get all the elements available with tag name 'p'
elements = element.find_elements(By.TAG_NAME, 'p')
for e in elements:
    print(e.text)
</code></pre>

<h4>获取活动元素</h4>
<p>它用于跟踪（或）查找在当前浏览上下文中具有焦点的DOM元素。
	 from selenium import webdriver
	 from selenium.webdriver.common.by import By</p>
<pre><code> driver = webdriver.Chrome()
 driver.get("https://www.google.com")
 driver.find_element(By.CSS_SELECTOR, '[name="q"]').send_keys("webElement")

   # Get attribute of current active element
 attr = driver.switch_to.active_element.get_attribute("title")
 print(attr)
</code></pre>

<h2>Web元素交互</h2>
<p>用于操纵表单的高级指令集.
仅有五种基本命令可用于元素的操作:</p>
<p><A href="https://w3c.github.io/webdriver/#element-click">点击</A> (适用于任何元素)</p>
<p><A href="https://w3c.github.io/webdriver/#element-send-keys">发送键位</A> (仅适用于文本字段和内容可编辑元素)</p>
<p><A href="https://w3c.github.io/webdriver/#element-send-keys">清除</A>(仅适用于文本字段和内容可编辑元素)</p>
<p>提交 (仅适用于表单元素)
选择 (参见 <A href="https://www.selenium.dev/zh-cn/documentation/webdriver/support_features/select_lists/">选择列表元素</A>)</p>
<h2><strong>定位器</strong></h2>
<p>在 WebDriver 中有 8 种不同的内置元素定位策略：</p>
<table>
<thead>
<tr>
	<th align="left">定位器 Locator</th>
	<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
	<td align="left">class name</td>
	<td align="left">定位class属性与搜索值匹配的元素（不允许使用复合类名）</td>
</tr>
<tr>
	<td align="left">css selector</td>
	<td align="left">定位 CSS 选择器匹配的元素</td>
</tr>
<tr>
	<td align="left">id</td>
	<td align="left">定位 id 属性与搜索值匹配的元素</td>
</tr>
<tr>
	<td align="left">name</td>
	<td align="left">定位 name 属性与搜索值匹配的元素</td>
</tr>
<tr>
	<td align="left">link text</td>
	<td align="left">定位link text可视文本与搜索值完全匹配的锚元素</td>
</tr>
<tr>
	<td align="left">partial link text</td>
	<td align="left">定位link text可视文本部分与搜索值部分匹配的锚点元素。如果匹配多个元素，则只选择第一个元素。</td>
</tr>
<tr>
	<td align="left">tag name</td>
	<td align="left">定位标签名称与搜索值匹配的元素</td>
</tr>
<tr>
	<td align="left">xpath</td>
	<td align="left">定位与 XPath 表达式匹配的元素</td>
</tr>
</tbody>
</table>
<h3>创建定位器</h3>
<p>要使用Selenium处理web元素，我们需要首先在网页上找到它。Selenium为我们提供了上述方法，使用这些方法我们可以在页面上定位元素。为了理解和创建定位器，我们将使用以下HTML片段。</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;style&gt;
.information {
  background-color: white;
  color: black;
  padding: 10px;
}
&lt;/style&gt;
&lt;h2&gt;Contact Selenium&lt;/h2&gt;

&lt;form action="/action_page.php"&gt;
  &lt;input type="radio" name="gender" value="m" /&gt;Male &amp;nbsp;
  &lt;input type="radio" name="gender" value="f" /&gt;Female &lt;br&gt;
  &lt;br&gt;
  &lt;label for="fname"&gt;First name:&lt;/label&gt;&lt;br&gt;
  &lt;input class="information" type="text" id="fname" name="fname" value="Jane"&gt;&lt;br&gt;&lt;br&gt;
  &lt;label for="lname"&gt;Last name:&lt;/label&gt;&lt;br&gt;
  &lt;input class="information" type="text" id="lname" name="lname" value="Doe"&gt;&lt;br&gt;&lt;br&gt;
  &lt;label for="newsletter"&gt;Newsletter:&lt;/label&gt;
  &lt;input type="checkbox" name="newsletter" value="1" /&gt;&lt;br&gt;&lt;br&gt;
  &lt;input type="submit" value="Submit"&gt;
&lt;/form&gt; 

&lt;p&gt;To know more about Selenium, visit the official page 
&lt;a href ="www.selenium.dev"&gt;Selenium Official Page&lt;/a&gt; 
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3>class name</h3>
<p>HTML页面web元素可以具有属性类。我们可以在上面显示的HTML片段中看到一个示例。我们可以使用Selenium中提供的类名定位器来识别这些元素。</p>
<pre><code>driver = webdriver.Chrome()
driver.find_element(By.CLASS_NAME, "information")
</code></pre>

<h3>css选择器</h3>
<p>CSS是用于设计HTML页面样式的语言。我们可以使用css选择器定位器策略来识别页面上的元素。如果元素有一个id，我们将定位器创建为css＝#id。否则，我们遵循的格式是css=[属性=值]。让我们看看上面HTML片段中的一个例子。我们将使用css为“名字”文本框创建定位器。</p>
<pre><code>driver = webdriver.Chrome()
driver.find_element(By.CSS_SELECTOR, "#fname")
</code></pre>

<h3>ID</h3>
<p>我们可以使用网页中元素的ID属性来定位它。通常，ID属性对于网页上的元素应该是唯一的。我们将使用它来识别姓氏字段。</p>
<pre><code>driver = webdriver.Chrome()
driver.find_element(By.ID, "lname")
</code></pre>

<h3>name</h3>
<p>我们可以使用网页中元素的NAME属性来定位它。通常，NAME属性对于网页上的元素应该是唯一的。我们将使用它来识别时事通讯复选框。</p>
<pre><code>driver = webdriver.Chrome()
driver.find_element(By.NAME, "newsletter")
</code></pre>

<h3>link text</h3>
<p>如果我们想要定位的元素是链接，我们可以使用链接文本定位器在网页上识别它。链接文本是链接显示的文本。在共享的HTML片段中，我们有一个可用的链接，让我们看看如何定位它。</p>
<pre><code>driver = webdriver.Chrome()
driver.find_element(By.LINK_TEXT, "Selenium Official Page")
</code></pre>

<h3>partial link text</h3>
<p>如果我们要定位的元素是链接，我们可以使用部分链接文本定位器在网页上识别它。链接文本是链接显示的文本。我们可以将部分文本作为值传递。在共享的HTML片段中，我们有一个可用的链接，让我们看看如何定位它。</p>
<pre><code>driver = webdriver.Chrome()
driver.find_element(By.PARTIAL_LINK_TEXT, "Official Page")
</code></pre>

<h3>tag name</h3>
<p>我们可以使用HTML标签本身作为定位器来识别页面上的web元素。从上面共享的HTML片段中，让我们使用其HTML标记“a”来识别链接。</p>
<pre><code>driver = webdriver.Chrome()
driver.find_element(By.TAG_NAME, "a")
</code></pre>

<h3>xpath</h3>
<p>HTML文档可以被视为XML文档，然后我们可以使用xpath，这将是到达感兴趣的元素以定位元素所经过的路径。XPath可以是绝对的XPath，它是从文档的根目录创建的。示例-/html/form/input[1]。这将返回阳性单选按钮。或者xpath可以是相对的。示例-//输入[@name='name']。这将返回名字文本框。让我们使用xpath为女性单选按钮创建定位器。</p>
<pre><code>driver = webdriver.Chrome()
driver.find_element(By.XPATH, "//input[@value='f']")
</code></pre>

<h2>关于网络元素的信息</h2>
<h3>是否显示</h3>
<p>此方法用于检查连接的元素是否正确显示在网页上. 返回一个 Boolean 值， 如果连接的元素显示在当前的浏览器上下文中，则为True，否则返回false。</p>
<p>此功能于W3C规范中提及， 但由于无法覆盖所有潜在条件而无法定义。 因此，Selenium不能期望驱动程序直接实现这种功能，现在依赖于直接执行大量JavaScript函数。 这个函数对一个元素的性质和在树中的关系做了许多近似的判断，以返回一个值。</p>
<pre><code># Navigate to the url
driver.get("https://www.selenium.dev/selenium/web/inputs.html")

# Get boolean value for is element display
is_email_visible = driver.find_element(By.NAME, "email_input").is_displayed()
</code></pre>

<h3>是否启用</h3>
<p>此方法用于检查所连接的元素在网页上是启用还是禁用状态。 返回一个布尔值，如果在当前浏览上下文中是 启用 状态，则返回 true，否则返回 false。</p>
<pre><code>    # Navigate to url
driver.get("http://www.google.com")

    # Returns true if element is enabled else returns false
value = driver.find_element(By.NAME, 'btnK').is_enabled()
</code></pre>

<h3>点击按钮:</h3>
<pre><code>    # 这不会工作
driver.find_element(By.TAG_NAME, 'button').click()
</code></pre>

<h3>是否被选定</h3>
<p>此方法确认相关的元素是否 已选定，常用于复选框、单选框、输入框和选择元素中。</p>
<p>该方法返回一个布尔值，如果在当前浏览上下文中 选择了 引用的元素，则返回 True，否则返回 False。</p>
<pre><code># Navigate to url
driver.get("https://the-internet.herokuapp.com/checkboxes")

# Returns true if element is checked else returns false
value = driver.find_element(By.CSS_SELECTOR, "input[type='checkbox']:first-of-type").is_selected()
</code></pre>

<h3>获取元素标签名</h3>
<p>此方法用于获取在当前浏览上下文中具有焦点的被引用元素的TagName。</p>
<pre><code># Navigate to url
driver.get("https://www.example.com")

# Returns TagName of the element
attr = driver.find_element(By.CSS_SELECTOR, "h1").tag_name
</code></pre>

<h3>使用 name 或 id</h3>
<p>如果您的 frame 或 iframe 具有 id 或 name 属性，则可以使用该属性。如果名称或 id 在页面上不是唯一的， 那么将切换到找到的第一个。</p>
<pre><code>    # 通过 id 切换框架
driver.switch_to.frame('buttonframe')

    # 单击按钮
driver.find_element(By.TAG_NAME, 'button').click()
</code></pre>

<h3>位置和大小</h3>
<p>用于获取参照元素的尺寸和坐标。</p>
<p>提取的数据主体包含以下详细信息：</p>
<p>


元素左上角的X轴位置元素左上角的y轴位置元素的高度元素的宽度</p>
<pre><code># Navigate to url
driver.get("https://www.example.com")

# Returns height, width, x and y coordinates referenced element
res = driver.find_element(By.CSS_SELECTOR, "h1").rect
</code></pre>

<h3>获取元素CSS值</h3>
<p>获取当前浏览上下文中元素的特定计算样式属性的值。</p>
<pre><code># Navigate to Url
driver.get('https://www.example.com')

# Retrieves the computed style property 'color' of linktext
cssValue = driver.find_element(By.LINK_TEXT, "More information...").value_of_css_property('color')
</code></pre>

<h3>文本内容</h3>
<p>获取特定元素渲染后的文本内容。</p>
<pre><code># Navigate to url
driver.get("https://www.example.com")

# Retrieves the text of the element
text = driver.find_element(By.CSS_SELECTOR, "h1").text
</code></pre>

<h3>获取特性或属性</h3>
<p>获取与 DOM 属性关联的运行时的值。 它返回与该元素的 DOM 特性或属性关联的数据。</p>
<pre><code># Navigate to the url
driver.get("https://www.selenium.dev/selenium/web/inputs.html")

# Identify the email text box
email_txt = driver.find_element(By.NAME, "email_input")

# Fetch the value property associated with the textbox
value_info = email_txt.get_attribute("value")
</code></pre>

<h1>浏览器交互</h1>
<h2>获取浏览器信息</h2>
<h3>获取标题</h3>
<p>从浏览器中读取当前页面的标题:</p>
<pre><code>driver.title
</code></pre>

<h3>获取当前 URL</h3>
<p>您可以从浏览器的地址栏读取当前的 URL，使用:</p>
<pre><code>driver.current_url
</code></pre>

<h3>打开网站</h3>
<p>启动浏览器后你要做的第一件事就是打开你的网站。这可以通过一行代码实现:</p>
<pre><code>driver.get("https://selenium.dev")
</code></pre>

<h3>后退</h3>
<p>按下浏览器的后退按钮:</p>
<pre><code>driver.back()
</code></pre>

<h3>前进</h3>
<p>按下浏览器的前进键:</p>
<pre><code>driver.forward()
</code></pre>

<h3>刷新</h3>
<p>刷新当前页面</p>
<pre><code>driver.refresh()
</code></pre>

<h3>Alerts 警告框</h3>
<p>其中最基本的称为警告框, 它显示一条自定义消息, 以及一个用于关闭该警告的按钮, 在大多数浏览器中标记为"确定"(OK). 在大多数浏览器中, 也可以通过按"关闭"(close)按钮将其关闭, 但这始终与“确定”按钮具有相同的作用. 查看样例警告框.</p>
<p>WebDriver可以从弹窗获取文本并接受或关闭这些警告.</p>
<pre><code># Click the link to activate the alert
driver.find_element(By.LINK_TEXT, "See an example alert").click()

# Wait for the alert to be displayed and store it in a variable
alert = wait.until(expected_conditions.alert_is_present())

# Store the alert text in a variable
text = alert.text

# Press the OK button
alert.accept()
</code></pre>

<h3>Confirm 确认框</h3>
<p>确认框类似于警告框, 不同之处在于用户还可以选择取消消息. 查看样例确认框.</p>
<p>此示例还呈现了警告的另一种实现:</p>
<pre><code># Click the link to activate the alert
driver.find_element(By.LINK_TEXT, "See a sample confirm").click()

# Wait for the alert to be displayed
wait.until(expected_conditions.alert_is_present())

# Store the alert in a variable for reuse
alert = driver.switch_to.alert

# Store the alert text in a variable
text = alert.text

# Press the Cancel button
alert.dismiss()
</code></pre>

<h3>Prompt 提示框</h3>
<p>提示框与确认框相似, 不同之处在于它们还包括文本输入. 与处理表单元素类似, 您可以使用WebDriver的sendKeys来填写响应. 这将完全替换占位符文本. 按下取消按钮将不会提交任何文本. 查看样例提示框.</p>
<pre><code># Click the link to activate the alert
driver.find_element(By.LINK_TEXT, "See a sample prompt").click()

# Wait for the alert to be displayed
wait.until(expected_conditions.alert_is_present())

# Store the alert in a variable for reuse
alert = Alert(driver)

# Type your message
alert.send_keys("Selenium")

# Press the OK button
alert.accept()
</code></pre>

<h3>添加 Cookie</h3>
<pre><code>from selenium import webdriver

driver = webdriver.Chrome()

driver.get("http://www.example.com")

# Adds the cookie into current browser context
driver.add_cookie({"name": "key", "value": "value"})
</code></pre>

<h3>获取命名的 Cookie</h3>
<p>此方法返回与cookie名称匹配的序列化cookie数据中所有关联的cookie.</p>
<pre><code>from selenium import webdriver

driver = webdriver.Chrome()

# Navigate to url
driver.get("http://www.example.com")

# Adds the cookie into current browser context
driver.add_cookie({"name": "foo", "value": "bar"})

# Get cookie details with named cookie 'foo'
print(driver.get_cookie("foo"))
</code></pre>

<h3>获取全部 Cookies</h3>
<p>此方法会针对当前访问上下文返回“成功的序列化cookie数据”. 如果浏览器不再可用, 则返回错误.
	from selenium import webdriver</p>
<pre><code>driver = webdriver.Chrome()

# Navigate to url
driver.get("http://www.example.com")

driver.add_cookie({"name": "test1", "value": "cookie1"})
driver.add_cookie({"name": "test2", "value": "cookie2"})

# Get all available cookies
print(driver.get_cookies())
</code></pre>

<h3>删除 Cookie</h3>
<p>此方法删除与提供的cookie名称匹配的cookie数据.</p>
<pre><code>from selenium import webdriver
driver = webdriver.Chrome()

# Navigate to url
driver.get("http://www.example.com")
driver.add_cookie({"name": "test1", "value": "cookie1"})
driver.add_cookie({"name": "test2", "value": "cookie2"})

# Delete a cookie with name 'test1'
driver.delete_cookie("test1")
</code></pre>

<h3>删除所有 Cookies</h3>
<p>此方法删除当前访问上下文的所有cookie.</p>
<pre><code>from selenium import webdriver
driver = webdriver.Chrome()

# Navigate to url
driver.get("http://www.example.com")
driver.add_cookie({"name": "test1", "value": "cookie1"})
driver.add_cookie({"name": "test2", "value": "cookie2"})

#  Deletes all cookies
driver.delete_all_cookies()
</code></pre>

<h2>窗口</h2>
<h3>窗口和标签页</h3>
<p>WebDriver 没有区分窗口和标签页。如果你的站点打开了一个新标签页或窗口，Selenium 将允许您使用窗口句柄来处理它。 每个窗口都有一个唯一的标识符，该标识符在单个会话中保持持久性。你可以使用以下方法获得当前窗口的窗口句柄:</p>
<pre><code>driver.current_window_handle
</code></pre>

<h3>切换窗口或标签页</h3>
<p>  单击在&lt;ahref=“https://seleniumhq.github.io"target="_blank”&gt;新窗口 中打开链接， 则屏幕会聚焦在新窗口或新标签页上，但 WebDriver 不知道操作系统认为哪个窗口是活动的。 要使用新窗口，您需要切换到它。 如果只有两个选项卡或窗口被打开，并且你知道从哪个窗口开始， 则你可以遍历 WebDriver， 通过排除法可以看到两个窗口或选项卡，然后切换到你需要的窗口或选项卡。</p>
<p>不过，Selenium 4 提供了一个新的 api NewWindow 它创建一个新选项卡 (或) 新窗口并自动切换到它。</p>
<pre><code>from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

    # 启动驱动程序
with webdriver.Firefox() as driver:
    # 打开网址
driver.get("https://seleniumhq.github.io")

    # 设置等待
    wait = WebDriverWait(driver, 10)

    # 存储原始窗口的 ID
    original_window = driver.current_window_handle

    # 检查一下，我们还没有打开其他的窗口
    assert len(driver.window_handles) == 1

    # 单击在新窗口中打开的链接
    driver.find_element(By.LINK_TEXT, "new window").click()

    # 等待新窗口或标签页
    wait.until(EC.number_of_windows_to_be(2))

    # 循环执行，直到找到一个新的窗口句柄
    for window_handle in driver.window_handles:
        if window_handle != original_window:
            driver.switch_to.window(window_handle)
            break

    # 等待新标签页完成加载内容
    wait.until(EC.title_is("SeleniumHQ Browser Automation"))
</code></pre>

<h3>创建新窗口(或)新标签页并且切换</h3>
<p>创建一个新窗口 (或) 标签页，屏幕焦点将聚焦在新窗口或标签在上。您不需要切换到新窗口 (或) 标签页。如果除了新窗口之外， 您打开了两个以上的窗口 (或) 标签页，您可以通过遍历 WebDriver 看到两个窗口或选项卡，并切换到非原始窗口。</p>
<pre><code>    # 打开新标签页并切换到新标签页
driver.switch_to.new_window('tab')

    # 打开一个新窗口并切换到新窗口
driver.switch_to.new_window('window')
</code></pre>

<h3>关闭窗口或标签页</h3>
<p>当你完成了一个窗口或标签页的工作时，_并且_它不是浏览器中最后一个打开的窗口或标签页时，你应该关闭它并切换回你之前使用的窗口。 假设您遵循了前一节中的代码示例，您将把前一个窗口句柄存储在一个变量中。把这些放在一起，你会得到:</p>
<pre><code>    #关闭标签页或窗口
driver.close()

    #切回到之前的标签页或窗口
driver.switch_to.window(original_window)
</code></pre>

<p>如果在关闭一个窗口后忘记切换回另一个窗口句柄，WebDriver 将在当前关闭的页面上执行，并触发一个 No Such Window Exception 无此窗口异常。必须切换回有效的窗口句柄才能继续执行。</p>
<h3>在会话结束时退出浏览器</h3>
<p>当你完成了浏览器会话，你应该调用 quit 退出，而不是 close 关闭:</p>
<pre><code>driver.quit()
</code></pre>

<p>退出将会</p>
<ul>
<li>
<p>关闭所有与 WebDriver 会话相关的窗口和选项卡</p>
<li>
<p>结束浏览器进程</p>
<li>
<p>结束后台驱动进程</p>
<li>
<p>通知 Selenium Grid 浏览器不再使用，以便可以由另一个会话使用它(如果您正在使用 Selenium Grid)</p>
</li>
</ul>
<p>调用 quit() 失败将留下额外的后台进程和端口运行在机器上，这可能在以后导致一些问题。</p>
<p>有的测试框架提供了一些方法和注释，您可以在测试结束时放入 teardown() 方法中。</p>
<pre><code>    # unittest teardown
    # https://docs.python.org/3/library/unittest.html?highlight=teardown#unittest.TestCase.tearDown
def tearDown(self):
self.driver.quit()
</code></pre>

<p>如果不在测试上下文中运行 WebDriver，您可以考虑使用 try / finally，这是大多数语言都提供的， 这样一个异常处理仍然可以清理 WebDriver 会话。</p>
<pre><code>try:
    #WebDriver 代码…
finally:
driver.quit()
</code></pre>

<p>Python 的 WebDriver 现在支持 Python 上下文管理器，当使用 with 关键字时，可以在执行结束时自动退出驱动程序。
	with webdriver.Firefox() as driver:
	  # WebDriver 代码…</p>
<pre><code># 在此缩进位置后 WebDriver 会自动退出
</code></pre>

<h2>窗口管理</h2>
<p>屏幕分辨率会影响 web 应用程序的呈现方式，因此 WebDriver 提供了移动和调整浏览器窗口大小的机制。</p>
<h3>获取窗口大小</h3>
<p>获取浏览器窗口的大小(以像素为单位)。</p>
<pre><code>    # 分别获取每个尺寸
width = driver.get_window_size().get("width")
height = driver.get_window_size().get("height")

    # 或者存储尺寸并在以后查询它们
size = driver.get_window_size()
width1 = size.get("width")
height1 = size.get("height")
</code></pre>

<h3>设置窗口大小</h3>
<p>恢复窗口并设置窗口大小。</p>
<pre><code>driver.set_window_size(1024, 768)
</code></pre>

<h3>得到窗口的位置</h3>
<p>获取浏览器窗口左上角的坐标。</p>
<pre><code>    # 分别获取每个尺寸
x = driver.get_window_position().get('x')
y = driver.get_window_position().get('y')

    # 或者存储尺寸并在以后查询它们
position = driver.get_window_position()
x1 = position.get('x')
y1 = position.get('y')
</code></pre>

<h3>设置窗口位置</h3>
<p>将窗口移动到设定的位置。</p>
<pre><code>    # 将窗口移动到主显示器的左上角
driver.set_window_position(0, 0)
</code></pre>

<h3>最大化窗口</h3>
<p>扩大窗口。对于大多数操作系统，窗口将填满屏幕，而不会阻挡操作系统自己的菜单和工具栏。</p>
<pre><code>driver.maximize_window()
</code></pre>

<h3>最小化窗口</h3>
<p>最小化当前浏览上下文的窗口. 这种命令的精准行为将作用于各个特定的窗口管理器.</p>
<p>最小化窗口通常将窗口隐藏在系统托盘中.</p>
<p>注意: 此功能适用于Selenium 4以及更高版本</p>
<pre><code>driver.minimize_window()
</code></pre>

<h3>全屏窗口</h3>
<p>填充整个屏幕，类似于在大多数浏览器中按下 F11。</p>
<pre><code>driver.fullscreen_window()
</code></pre>

<h3>屏幕截图</h3>
<p>用于捕获当前浏览上下文的屏幕截图. WebDriver端点 屏幕截图 返回以Base64格式编码的屏幕截图.</p>
<pre><code>from selenium import webdriver

driver = webdriver.Chrome()

    # Navigate to url
driver.get("http://www.example.com")

    # Returns and base64 encoded string into image
driver.save_screenshot('./image.png')

driver.quit()
</code></pre>

<h3>元素屏幕截图</h3>
<p>用于捕获当前浏览上下文的元素的屏幕截图. WebDriver端点 屏幕截图 返回以Base64格式编码的屏幕截图</p>
<pre><code>from selenium import webdriver
from selenium.webdriver.common.by import By

driver = webdriver.Chrome()

    # Navigate to url
driver.get("http://www.example.com")

ele = driver.find_element(By.CSS_SELECTOR, 'h1')

    # Returns and base64 encoded string into image
ele.screenshot('./image.png')

driver.quit()
</code></pre>

<h3>执行脚本</h3>
<p>在当前frame或者窗口的上下文中，执行JavaScript代码片段.</p>
<pre><code>    # Stores the header element
header = driver.find_element(By.CSS_SELECTOR, "h1")

    # Executing JavaScript to capture innerText of header element
driver.execute_script('return arguments[0].innerText', header)
</code></pre>

<h3>打印页面</h3>
<p>打印当前浏览器内的页面</p>
<p>注意: 此功能需要无头模式下的Chromium浏览器</p>
<pre><code>from selenium.webdriver.common.print_page_options import PrintOptions

    print_options = PrintOptions()
    print_options.page_ranges = ['1-2']

    driver.get("printPage.html")

    base64code = driver.print_page(print_options)
</code></pre>

<h3>点击并按住</h3>
<p>此方法将鼠标移动到元素的中心与按下鼠标左键相结合。这对于聚焦特定元素很有用</p>
<pre><code>clickable = driver.find_element(By.ID, "clickable")
ActionChains(driver)\
    .click_and_hold(clickable)\
    .perform()
</code></pre>

<h3>点击并释放</h3>
<p>此方法将移动到元素的中心与按住并释放鼠标左键相结合。这也被称为“点击”：</p>
<pre><code>clickable = driver.find_element(By.ID, "click")
ActionChains(driver)\
    .click(clickable)\
    .perform()
</code></pre>

<h3>上下文单击</h3>
<p>这种方法将移动到元素的中心与按下和释放鼠标右键（按钮2）相结合。这也被称为“右键单击”：</p>
<pre><code>clickable = driver.find_element(By.ID, "clickable")
ActionChains(driver)\
    .context_click(clickable)\
    .perform()
</code></pre>

<h3>后退单击</h3>
<p>没有方便的方法，只是按下并释放鼠标按钮3</p>
<pre><code>action = ActionBuilder(driver)
action.pointer_action.pointer_down(MouseButton.BACK)
action.pointer_action.pointer_up(MouseButton.BACK)
action.perform()
</code></pre>

<h3>向前单击</h3>
<p>没有方便的方法，只是按下并释放鼠标按钮4</p>
<pre><code>action = ActionBuilder(driver)
action.pointer_action.pointer_down(MouseButton.FORWARD)
action.pointer_action.pointer_up(MouseButton.FORWARD)
action.perform()
</code></pre>

<h3>双击</h3>
<p>这种方法将移动到元素的中心与按下和释放鼠标左键两次相结合。</p>
<pre><code>clickable = driver.find_element(By.ID, "clickable")
ActionChains(driver)\
    .double_click(clickable)\
    .perform()
</code></pre>

<h3>移动到元素</h3>
<p>此方法将鼠标移动到元素的视图中心点。这也被称为“悬停”。请注意，元素必须在视口中，否则命令将出错。</p>
<pre><code>hoverable = driver.find_element(By.ID, "hover")
ActionChains(driver)\
    .move_to_element(hoverable)\
    .perform()
</code></pre>

<h2>按偏移量移动</h2>
<p>这些方法首先将鼠标移动到指定的原点，然后移动所提供偏移中的像素数。请注意，鼠标的位置必须在视口中，否则命令将出错。</p>
<h3>与元素的偏移</h3>
<p>此方法将鼠标移动到图元的视图中心点，然后按提供的偏移量移动。</p>
<pre><code>mouse_tracker = driver.find_element(By.ID, "mouse-tracker")
ActionChains(driver)\
    .move_to_element_with_offset(mouse_tracker, 8, 0)\
    .perform()
</code></pre>

<h3>与视口的偏移</h3>
<p>此方法将鼠标从当前视口的左上角移动所提供的偏移量。</p>
<pre><code>action = ActionBuilder(driver)
action.pointer_action.move_to_location(8, 0)
action.perform()
</code></pre>

<h3>与当前指针位置的偏移</h3>
<p>
此方法将鼠标从当前位置移动用户提供的偏移量。如果之前没有移动过鼠标，则该位置将位于视口的左上角。请注意，当页面滚动时，指针位置不会改变。请注意，第一个参数X指定在为正数时向右移动，而第二个参数Y指定在为负数时向下移动。因此，moveByOffset（30，-10）从当前鼠标位置向右移动30，向上移动10。</p>
<pre><code>ActionChains(driver)\
    .move_by_offset( 13, 15)\
    .perform()
</code></pre>

<h3>在元素上拖放</h3>
<p>该方法首先在源元素上执行点击并按住，移动到目标元素的位置，然后释放鼠标。</p>
<pre><code>draggable = driver.find_element(By.ID, "draggable")
droppable = driver.find_element(By.ID, "droppable")
ActionChains(driver)\
    .drag_and_drop(draggable, droppable)\
    .perform()
</code></pre>

<h3>按偏移拖放</h3>
<p>此方法首先在源元素上单击并按住，移动到给定的偏移量，然后释放鼠标</p>
<pre><code>draggable = driver.find_element(By.ID, "draggable")
start = draggable.location
finish = driver.find_element(By.ID, "droppable").location
ActionChains(driver)\
    .drag_and_drop_by_offset(draggable, finish['x'] - start['x'], finish['y'] - start['y'])\
    .perform()
</code></pre>















































</body>
</html>